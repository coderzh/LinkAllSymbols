#!/usr/bin/python

import argparse
import subprocess
import re

regex = re.compile(r"\s+.*\s([\?_]+.*)")

exclude = ["Dog"]

def gen_header_file_for_lib(lib_path, header_path):
    cmd = ['dumpbin.exe','/linkermember', lib_path]
    lines = execute_command(cmd)
    symbols = find_matches(lines, regex, exclude)

    with open(header_path, 'w') as f:
        header_guard = "LINK_ALL_SYMBOLS_H_"
        f.write("#ifndef " + header_guard + '\n')
        f.write("#define " + header_guard + '\n')
        f.write("// Generated by GenLinkerSymbols.py. Do not modify! \n\n")

        for symbol in symbols:
            pragma_line = '#pragma comment(linker, "/include:' + symbol + '")'
            f.write(pragma_line + '\n')
        f.write("\n#endif // " + header_guard + '\n')

    print("Link symbols count: %s" % len(symbols))


def execute_command(cmd):
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (std_out, std_err) = p.communicate()
    if p.returncode != 0:
        raise subprocess.CalledProcessError(p.returncode, cmd)

    std_out_lines = std_out.splitlines()
    return std_out_lines

def find_matches(lines, regex, exclude_list):
    def match(line):
        m = regex.match(line)
        if m:
            return m.group(1).split()[0]
        return None

    def exclude_filter(line):
        if not line:
            return False

        for exclude in exclude_list:
            if line.find(exclude) >= 0:
                return False
        return True

    matches = filter(exclude_filter, map(match, lines))
    return list(set(matches))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Gen linker all symbols header file')
    parser.add_argument('lib', help='.lib file path')
    parser.add_argument('header', help='output .h file path')
    args = parser.parse_args()
    gen_header_file_for_lib(args.lib, args.header)
